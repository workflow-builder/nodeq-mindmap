(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('d3')) :
    typeof define === 'function' && define.amd ? define(['exports', 'd3'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.NodeQMindMap = {}, global.d3));
})(this, (function (exports, d3) { 'use strict';

    function _interopNamespaceDefault(e) {
        var n = Object.create(null);
        if (e) {
            Object.keys(e).forEach(function (k) {
                if (k !== 'default') {
                    var d = Object.getOwnPropertyDescriptor(e, k);
                    Object.defineProperty(n, k, d.get ? d : {
                        enumerable: true,
                        get: function () { return e[k]; }
                    });
                }
            });
        }
        n.default = e;
        return Object.freeze(n);
    }

    var d3__namespace = /*#__PURE__*/_interopNamespaceDefault(d3);

    class JsonSchemaAdapter {
        static convertToStandard(data) {
            if (!data || typeof data !== 'object') {
                return { topic: 'Invalid Data', summary: 'Unable to process data' };
            }
            const result = {
                topic: this.extractTopic(data),
                summary: this.extractSummary(data),
                skills: this.extractSkills(data)
            };
            const children = this.extractChildren(data);
            if (children && children.length > 0) {
                result.children = children.map(child => this.convertToStandard(child));
            }
            return result;
        }
        static extractTopic(obj) {
            const topicFields = ['topic', 'name', 'title', 'label', 'key', 'id'];
            for (const field of topicFields) {
                if (obj[field] && typeof obj[field] === 'string') {
                    return obj[field];
                }
            }
            return Object.keys(obj)[0] || 'Unnamed Node';
        }
        static extractSummary(obj) {
            const summaryFields = ['summary', 'description', 'content', 'detail', 'info', 'text'];
            for (const field of summaryFields) {
                if (obj[field] && typeof obj[field] === 'string') {
                    return obj[field];
                }
            }
            return undefined;
        }
        static extractSkills(obj) {
            const skillFields = ['skills', 'tags', 'categories', 'keywords', 'attributes'];
            for (const field of skillFields) {
                if (Array.isArray(obj[field])) {
                    return obj[field].filter(item => typeof item === 'string');
                }
            }
            return undefined;
        }
        static extractChildren(obj) {
            const childFields = ['children', 'items', 'nodes', 'subitems', 'elements', 'branches'];
            for (const field of childFields) {
                if (Array.isArray(obj[field])) {
                    return obj[field];
                }
            }
            return undefined;
        }
    }
    class NodeQMindMap {
        constructor(config) {
            this.svg = null;
            this.g = null;
            this.config = {
                container: config.container,
                data: config.data,
                width: config.width || 800,
                height: config.height || 600,
                theme: {
                    nodeColor: '#4299e1',
                    textColor: '#2d3748',
                    linkColor: '#a0aec0',
                    backgroundColor: '#ffffff',
                    fontSize: 14,
                    fontFamily: 'Arial, sans-serif',
                    ...config.theme
                },
                interactive: config.interactive !== undefined ? config.interactive : true,
                zoomable: config.zoomable !== undefined ? config.zoomable : true,
                collapsible: config.collapsible !== undefined ? config.collapsible : true,
                nodeSpacing: config.nodeSpacing || 200,
                levelSpacing: config.levelSpacing || 300,
                onNodeClick: config.onNodeClick || (() => { }),
                onNodeHover: config.onNodeHover || (() => { })
            };
            // Get container element
            if (typeof this.config.container === 'string') {
                const element = document.querySelector(this.config.container);
                if (!element) {
                    throw new Error(`Container element not found: ${this.config.container}`);
                }
                this.container = element;
            }
            else {
                this.container = this.config.container;
            }
            // Convert data to standard format
            this.data = JsonSchemaAdapter.convertToStandard(this.config.data);
        }
        render() {
            this.createSVG();
            this.renderMindMap();
        }
        updateData(data) {
            this.config.data = data;
            this.data = JsonSchemaAdapter.convertToStandard(data);
            this.renderMindMap();
        }
        updateTheme(theme) {
            this.config.theme = { ...this.config.theme, ...theme };
            this.renderMindMap();
        }
        exportSVG() {
            if (!this.svg)
                return '';
            return new XMLSerializer().serializeToString(this.svg.node());
        }
        destroy() {
            if (this.svg) {
                this.svg.remove();
            }
        }
        createSVG() {
            // Clear existing content
            d3__namespace.select(this.container).selectAll('*').remove();
            // Create SVG
            this.svg = d3__namespace.select(this.container)
                .append('svg')
                .attr('width', this.config.width)
                .attr('height', this.config.height)
                .style('background-color', this.config.theme.backgroundColor);
            // Create main group for zooming/panning
            this.g = this.svg.append('g');
            // Add zoom behavior if enabled
            if (this.config.zoomable) {
                const zoom = d3__namespace.zoom()
                    .scaleExtent([0.1, 3])
                    .on('zoom', (event) => {
                    this.g.attr('transform', event.transform);
                });
                this.svg.call(zoom);
            }
        }
        renderMindMap() {
            if (!this.g)
                return;
            // Clear existing content
            this.g.selectAll('*').remove();
            // Create hierarchy
            const root = d3__namespace.hierarchy(this.data);
            // Create tree layout
            const treeLayout = d3__namespace.tree()
                .size([this.config.height - 100, this.config.width - 200])
                .separation((a, b) => a.parent === b.parent ? 1 : 2);
            // Generate tree
            const treeData = treeLayout(root);
            // Create links
            this.g.selectAll('.link')
                .data(treeData.links())
                .enter()
                .append('path')
                .attr('class', 'link')
                .attr('d', d3__namespace.linkHorizontal()
                .x(d => d.y + 100)
                .y(d => d.x + 50))
                .style('fill', 'none')
                .style('stroke', this.config.theme.linkColor)
                .style('stroke-width', 2);
            // Create nodes
            const nodes = this.g.selectAll('.node')
                .data(treeData.descendants())
                .enter()
                .append('g')
                .attr('class', 'node')
                .attr('transform', d => `translate(${d.y + 100},${d.x + 50})`)
                .style('cursor', this.config.interactive ? 'pointer' : 'default');
            // Add node circles
            nodes.append('circle')
                .attr('r', 25)
                .style('fill', this.config.theme.nodeColor)
                .style('stroke', '#fff')
                .style('stroke-width', 3);
            // Add node labels
            nodes.append('text')
                .attr('dy', '.35em')
                .attr('x', d => d.children ? -30 : 30)
                .style('text-anchor', d => d.children ? 'end' : 'start')
                .style('font-family', this.config.theme.fontFamily)
                .style('font-size', `${this.config.theme.fontSize}px`)
                .style('fill', this.config.theme.textColor)
                .text(d => d.data.topic);
            // Add interactivity
            if (this.config.interactive) {
                nodes.on('click', (event, d) => {
                    this.config.onNodeClick(d.data);
                });
                nodes.on('mouseover', (event, d) => {
                    this.config.onNodeHover(d.data);
                });
            }
        }
        zoomToFit() {
            if (!this.svg || !this.g)
                return;
            const bounds = this.g.node().getBBox();
            const fullWidth = this.config.width;
            const fullHeight = this.config.height;
            const width = bounds.width;
            const height = bounds.height;
            const midX = bounds.x + width / 2;
            const midY = bounds.y + height / 2;
            if (width === 0 || height === 0)
                return;
            const scale = 0.9 / Math.max(width / fullWidth, height / fullHeight);
            const translate = [fullWidth / 2 - scale * midX, fullHeight / 2 - scale * midY];
            const zoom = d3__namespace.zoom();
            this.svg
                .transition()
                .duration(750)
                .call(zoom.transform, d3__namespace.zoomIdentity.translate(translate[0], translate[1]).scale(scale));
        }
    }

    exports.JsonSchemaAdapter = JsonSchemaAdapter;
    exports.NodeQMindMap = NodeQMindMap;
    exports.default = NodeQMindMap;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
